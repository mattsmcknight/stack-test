"""Bootstrap command for creating new environments."""

from datetime import datetime, timezone
from pathlib import Path
from typing import Annotated

import typer
import yaml
from rich.console import Console
from rich.panel import Panel
from rich.table import Table

from platform.config import ClusterConfig, Environment, Paths
from platform.services import ArgoCDService, AWSService, EksctlService, GitService, KubernetesService

app = typer.Typer(help="Bootstrap a new environment")
console = Console()


def generate_import_yaml(config: ClusterConfig, region: str) -> str:
    """Generate the import-existing.yaml content."""
    resources = []

    # VPC
    resources.append({
        "apiVersion": "ec2.aws.upbound.io/v1beta1",
        "kind": "VPC",
        "metadata": {
            "name": "main",
            "annotations": {"crossplane.io/external-name": config.vpc_id},
        },
        "spec": {
            "managementPolicies": ["Observe", "LateInitialize", "Update"],
            "deletionPolicy": "Orphan",
            "forProvider": {"region": region},
        },
    })

    # Internet Gateway
    if config.igw_id:
        resources.append({
            "apiVersion": "ec2.aws.upbound.io/v1beta1",
            "kind": "InternetGateway",
            "metadata": {
                "name": "main",
                "annotations": {"crossplane.io/external-name": config.igw_id},
            },
            "spec": {
                "managementPolicies": ["Observe", "LateInitialize", "Update"],
                "deletionPolicy": "Orphan",
                "forProvider": {"region": region},
            },
        })

    # Private Subnets
    for az, subnet_id in config.private_subnets.items():
        resources.append({
            "apiVersion": "ec2.aws.upbound.io/v1beta1",
            "kind": "Subnet",
            "metadata": {
                "name": f"private-{az}",
                "annotations": {"crossplane.io/external-name": subnet_id},
            },
            "spec": {
                "managementPolicies": ["Observe", "LateInitialize", "Update"],
                "deletionPolicy": "Orphan",
                "forProvider": {"region": region},
            },
        })

    # Public Subnets
    for az, subnet_id in config.public_subnets.items():
        resources.append({
            "apiVersion": "ec2.aws.upbound.io/v1beta1",
            "kind": "Subnet",
            "metadata": {
                "name": f"public-{az}",
                "annotations": {"crossplane.io/external-name": subnet_id},
            },
            "spec": {
                "managementPolicies": ["Observe", "LateInitialize", "Update"],
                "deletionPolicy": "Orphan",
                "forProvider": {"region": region},
            },
        })

    # NAT Gateway
    if config.nat_id:
        resources.append({
            "apiVersion": "ec2.aws.upbound.io/v1beta1",
            "kind": "NATGateway",
            "metadata": {
                "name": "nat-a",
                "annotations": {"crossplane.io/external-name": config.nat_id},
            },
            "spec": {
                "managementPolicies": ["Observe", "LateInitialize", "Update"],
                "deletionPolicy": "Orphan",
                "forProvider": {"region": region},
            },
        })

    # Generate YAML with header
    header = f"""# Auto-generated by platform bootstrap
# Cluster: {config.cluster_name}
# Environment: {config.environment.value}
# Generated: {datetime.now(timezone.utc).isoformat()}
#
# These resources are imported from eksctl-created infrastructure
"""

    yaml_docs = [yaml.dump(r, default_flow_style=False) for r in resources]
    return header + "\n---\n".join(yaml_docs)


def update_aws_config(config_path: Path, config: ClusterConfig) -> None:
    """Update aws-config.yaml with actual resource IDs."""
    if not config_path.exists():
        console.print(f"[yellow]Warning: {config_path} not found, skipping update[/yellow]")
        return

    content = config_path.read_text()

    # Replace placeholders
    replacements = {
        f"subnet-{config.environment.value}-private-a": config.private_subnets.get("a", ""),
        f"subnet-{config.environment.value}-private-b": config.private_subnets.get("b", ""),
        f"subnet-{config.environment.value}-private-c": config.private_subnets.get("c", ""),
        f"vpc-{config.environment.value}": config.vpc_id,
        "111111111111": config.account_id,
        "DEV_OIDC_ID": config.oidc_id,
        "PROD_OIDC_ID": config.oidc_id,
        f"{config.environment.value.upper()}_OIDC_ID": config.oidc_id,
    }

    for placeholder, value in replacements.items():
        content = content.replace(placeholder, value)

    config_path.write_text(content)
    console.print(f"[green]Updated {config_path.name}[/green]")


def load_permission_boundary(policy_path: Path, account_id: str) -> dict:
    """Load and customize the permission boundary policy."""
    if not policy_path.exists():
        raise typer.Exit(f"Permission boundary file not found: {policy_path}")

    import json
    content = policy_path.read_text()
    content = content.replace("ACCOUNT_ID", account_id)
    return json.loads(content)


@app.command()
def dev(
    cluster_name: Annotated[str, typer.Option("--cluster-name", "-n", help="EKS cluster name")] = "stack-test-dev",
    region: Annotated[str, typer.Option("--region", "-r", help="AWS region")] = "us-east-1",
    skip_cluster_create: Annotated[bool, typer.Option("--skip-cluster-create", help="Skip EKS cluster creation")] = False,
    skip_git_push: Annotated[bool, typer.Option("--skip-git-push", help="Skip git commit and push")] = False,
    skip_sync: Annotated[bool, typer.Option("--skip-sync", help="Skip ArgoCD sync orchestration")] = False,
) -> None:
    """Bootstrap a dev environment."""
    _bootstrap(Environment.DEV, cluster_name, region, skip_cluster_create, skip_git_push, skip_sync)


@app.command()
def prod(
    cluster_name: Annotated[str, typer.Option("--cluster-name", "-n", help="EKS cluster name")] = "stack-test-prod",
    region: Annotated[str, typer.Option("--region", "-r", help="AWS region")] = "us-east-1",
    skip_cluster_create: Annotated[bool, typer.Option("--skip-cluster-create", help="Skip EKS cluster creation")] = False,
    skip_git_push: Annotated[bool, typer.Option("--skip-git-push", help="Skip git commit and push")] = False,
    skip_sync: Annotated[bool, typer.Option("--skip-sync", help="Skip ArgoCD sync orchestration")] = False,
) -> None:
    """Bootstrap a prod environment."""
    _bootstrap(Environment.PROD, cluster_name, region, skip_cluster_create, skip_git_push, skip_sync)


def _bootstrap(
    env: Environment,
    cluster_name: str,
    region: str,
    skip_cluster_create: bool,
    skip_git_push: bool,
    skip_sync: bool,
) -> None:
    """Main bootstrap logic."""
    console.print(Panel(f"[bold blue]Bootstrapping {env.value} environment[/bold blue]"))

    # Initialize config and paths
    config = ClusterConfig(
        environment=env,
        cluster_name=cluster_name,
        region=region,
    )
    paths = Paths.from_git_root()

    # Initialize services
    aws = AWSService(region)
    eksctl = EksctlService(region)
    k8s = KubernetesService()
    git = GitService(paths.root)
    argocd = ArgoCDService()

    # Phase 1: Create EKS Cluster
    console.print("\n[bold]Phase 1: Create EKS Cluster[/bold]")
    if not skip_cluster_create:
        eksctl.update_cluster_config(paths.eksctl_config, cluster_name, region)
        eksctl.create_cluster(cluster_name, paths.eksctl_config)
    else:
        console.print("[yellow]Skipping cluster creation[/yellow]")

    aws.update_kubeconfig(cluster_name)

    # Phase 2: Populate config from AWS
    console.print("\n[bold]Phase 2: Gather AWS resource information[/bold]")
    config = aws.populate_cluster_config(config)

    # Phase 3: Create Crossplane IAM
    console.print("\n[bold]Phase 3: Setup Crossplane IAM[/bold]")
    policy_doc = load_permission_boundary(paths.permission_boundary, config.account_id)
    aws.create_permission_boundary(config, policy_doc)
    aws.create_crossplane_role(config)

    # Phase 4: Install ArgoCD
    console.print("\n[bold]Phase 4: Install ArgoCD[/bold]")
    k8s.install_argocd()

    # Phase 5: Create Crossplane namespace and cluster-info
    console.print("\n[bold]Phase 5: Setup Crossplane namespace[/bold]")
    k8s.create_namespace("crossplane-system")
    k8s.create_cluster_info_configmap(config)

    # Phase 6: Generate import files for overlay
    console.print(f"\n[bold]Phase 6: Generate {env.value} overlay files[/bold]")
    overlay_path = paths.overlay(env)
    overlay_path.mkdir(parents=True, exist_ok=True)

    import_yaml = generate_import_yaml(config, region)
    import_file = overlay_path / "import-existing.yaml"
    import_file.write_text(import_yaml)
    console.print(f"[green]Generated {import_file.name}[/green]")

    aws_config_file = overlay_path / "aws-config.yaml"
    update_aws_config(aws_config_file, config)

    # Phase 7: Commit and push
    console.print("\n[bold]Phase 7: Commit changes to git[/bold]")
    if not skip_git_push:
        git.commit_and_push(config, [overlay_path])
    else:
        console.print("[yellow]Skipping git push[/yellow]")

    # Phase 8: Apply ApplicationSets
    console.print("\n[bold]Phase 8: Apply ArgoCD ApplicationSets[/bold]")
    k8s.apply_applicationsets(paths.argocd)

    # Phase 9: Sync applications in order
    if not skip_sync:
        console.print("\n[bold]Phase 9: Sync applications in dependency order[/bold]")
        if not argocd.sync_in_order(env.value):
            console.print("[yellow]Some applications may need manual attention[/yellow]")
            console.print("Check ArgoCD UI: kubectl port-forward svc/argocd-server -n argocd 8080:443")
    else:
        console.print("\n[yellow]Skipping sync orchestration[/yellow]")
        console.print("Applications will sync based on their autoSync settings")

    # Output summary
    _print_summary(config)


def _print_summary(config: ClusterConfig) -> None:
    """Print the bootstrap summary."""
    console.print("\n")
    console.print(Panel("[bold green]Bootstrap Complete![/bold green]"))

    # Cluster info table
    table = Table(title="Cluster Information")
    table.add_column("Property", style="cyan")
    table.add_column("Value", style="green")

    table.add_row("Environment", config.environment.value)
    table.add_row("Cluster Name", config.cluster_name)
    table.add_row("Region", config.region)
    table.add_row("Account ID", config.account_id)
    table.add_row("VPC ID", config.vpc_id)
    table.add_row("OIDC ID", config.oidc_id)

    console.print(table)

    # ArgoCD access
    console.print("\n[bold]ArgoCD Access[/bold]")
    console.print("Get admin password:")
    console.print("  [dim]kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d[/dim]")
    console.print("\nPort-forward UI:")
    console.print("  [dim]kubectl port-forward svc/argocd-server -n argocd 8080:443[/dim]")
    console.print("\nOpen: [link]https://localhost:8080[/link] (username: admin)")

    # What happens next
    console.print(f"\n[bold]What Happens Next[/bold]")
    console.print(f"ArgoCD will sync the {config.environment.value} environment:")
    console.print("  Wave -3: Crossplane")
    console.print("  Wave -2: Crossplane Providers + ESO")
    console.print("  Wave  0: Infrastructure (uses imported VPC/subnets)")
    console.print("  Wave  0: Supabase")
    console.print("\nWatch progress:")
    console.print("  [dim]kubectl get applications -n argocd -w[/dim]")
