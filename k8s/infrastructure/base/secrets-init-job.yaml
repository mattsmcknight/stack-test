# One-time Job to generate and store secrets in AWS Secrets Manager
# Runs as part of infrastructure sync (before ESO needs them)
apiVersion: batch/v1
kind: Job
metadata:
  name: secrets-init
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  ttlSecondsAfterFinished: 300
  template:
    spec:
      serviceAccountName: secrets-init
      restartPolicy: OnFailure
      containers:
        - name: secrets-init
          image: amazon/aws-cli:2.15.0
          env:
            - name: AWS_REGION
              valueFrom:
                configMapKeyRef:
                  name: cluster-info
                  key: region
            - name: ENV
              value: "dev"  # Patched by overlay
          command:
            - /bin/bash
            - -c
            - |
              set -e

              # Check if secrets already exist
              if aws secretsmanager describe-secret --secret-id "stack-test/${ENV}/aurora" 2>/dev/null; then
                echo "Secrets already exist, skipping initialization"
                exit 0
              fi

              echo "Generating secrets..."

              # Generate random values using AWS Secrets Manager
              POSTGRES_PASSWORD=$(aws secretsmanager get-random-password --password-length 32 --exclude-punctuation --query RandomPassword --output text)
              JWT_SECRET=$(aws secretsmanager get-random-password --password-length 64 --exclude-punctuation --query RandomPassword --output text)
              DASHBOARD_PASSWORD=$(aws secretsmanager get-random-password --password-length 32 --exclude-punctuation --query RandomPassword --output text)

              # For JWT tokens, we'll use a simpler approach - just store the secret
              # The actual JWT tokens can be generated by the application or a proper JWT library

              # Create Aurora credentials
              aws secretsmanager create-secret \
                --name "stack-test/${ENV}/aurora" \
                --description "Aurora database credentials" \
                --secret-string "{\"username\":\"postgres\",\"password\":\"${POSTGRES_PASSWORD}\",\"host\":\"postgres.supabase.internal\",\"port\":\"5432\",\"database\":\"postgres\"}"

              # Create Supabase secrets
              aws secretsmanager create-secret \
                --name "stack-test/${ENV}/supabase" \
                --description "Supabase application secrets" \
                --secret-string "{\"jwt-secret\":\"${JWT_SECRET}\",\"anon-key\":\"generate-on-first-use\",\"service-role-key\":\"generate-on-first-use\",\"dashboard-username\":\"supabase\",\"dashboard-password\":\"${DASHBOARD_PASSWORD}\"}"

              # Create SMTP placeholder
              aws secretsmanager create-secret \
                --name "stack-test/${ENV}/smtp" \
                --description "SMTP credentials" \
                --secret-string "{\"host\":\"\",\"port\":\"587\",\"user\":\"\",\"password\":\"\",\"sender\":\"noreply@example.com\"}"

              echo "Secrets created successfully"
---
# ServiceAccount for the secrets-init job (needs IRSA)
apiVersion: v1
kind: ServiceAccount
metadata:
  name: secrets-init
  annotations:
    eks.amazonaws.com/role-arn: ""  # Patched by overlay
---
# IAM Role for secrets-init (created by Crossplane)
apiVersion: iam.aws.upbound.io/v1beta1
kind: Role
metadata:
  name: secrets-init-role
spec:
  forProvider:
    assumeRolePolicy: |
      {
        "Version": "2012-10-17",
        "Statement": [
          {
            "Effect": "Allow",
            "Principal": {
              "Federated": "arn:aws:iam::ACCOUNT_ID:oidc-provider/OIDC_PROVIDER"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
              "StringEquals": {
                "OIDC_PROVIDER:sub": "system:serviceaccount:crossplane-system:secrets-init"
              }
            }
          }
        ]
      }
    inlinePolicy:
      - name: secrets-manager-access
        policy: |
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "secretsmanager:CreateSecret",
                  "secretsmanager:DescribeSecret",
                  "secretsmanager:GetRandomPassword"
                ],
                "Resource": "*"
              }
            ]
          }
